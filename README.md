# LUSH - Lua based Unix Shell

## Goals

The ultimate goal is to make an environment in which writing the shell part of a program like git is
1. Easy to do
2. Assisted by tools

What do we mean by this? Let us describe the problem with a case study of a popular program

### Git bisect
```sh
#!/bin/sh

USAGE='[help|start|bad|good|new|old|terms|skip|next|reset|visualize|view|replay|log|run]' # list of all subcommands. Could be autogenerated by the shell...
LONG_USAGE='git bisect help
	print this long help message.
git bisect start [--term-{new,bad}=<term> --term-{old,good}=<term>]
		 [--no-checkout] [--first-parent] [<bad> [<good>...]] [--] [<pathspec>...]
	reset bisect state and start bisection.
git bisect (bad|new) [<rev>]
	mark <rev> a known-bad revision/
		a revision after change in a given property.
git bisect (good|old) [<rev>...]
	mark <rev>... known-good revisions/
		revisions before change in a given property.
git bisect terms [--term-good | --term-bad]
	show the terms used for old and new commits (default: bad, good)
git bisect skip [(<rev>|<range>)...]
	mark <rev>... untestable revisions.
git bisect next
	find next bisection to test and check it out.
git bisect reset [<commit>]
	finish bisection search and go back to commit.
git bisect (visualize|view)
	show bisect status in gitk.
git bisect replay <logfile>
	replay bisection log.
git bisect log
	show bisect log.
git bisect run <cmd>...
	use <cmd>... to automatically bisect.

Please use "git help bisect" to get the full man page.'
# Well. The documentation could be attached to each command individually and sticked
# together by the shell

OPTIONS_SPEC=
. git-sh-setup

_x40='[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]'
_x40="$_x40$_x40$_x40$_x40$_x40$_x40$_x40$_x40"
TERM_BAD=bad #Configurable values
TERM_GOOD=good

bisect_visualize() {
	git bisect--helper --bisect-next-check $TERM_GOOD $TERM_BAD fail || exit

	if    test $# = 0
 # Wait what was $# again? Ah count of args. why not: 'length $args = 0' ?
 # Or 'if empty $args'. the verbose version has as many characters as the version
 # with special $# syntax
	then
		if test -n "${DISPLAY+set}${SESSIONNAME+set}${MSYSTEM+set}${SECURITYSESSIONID+set}" &&
			type gitk >/dev/null 2>&1
		then
			set gitk
		else
			set git log
		fi
	else
		case "$1" in
		git*|tig) ;;
		-*)	set git log "$@" ;;
		*)	set git "$@" ;;
		esac
	fi

	eval '"$@"' --bisect -- $(cat "$GIT_DIR/BISECT_NAMES")
}

bisect_run () {
	git bisect--helper --bisect-next-check $TERM_GOOD $TERM_BAD fail || exit

	test -n "$*" || die "$(gettext "bisect run failed: no command provided.")"

	while true
	do
		command="$@"
		eval_gettextln "running \$command"
		"$@"
		res=$?

		# Check for really bad run error.
		if [ $res -lt 0 -o $res -ge 128 ]
		then
			eval_gettextln "bisect run failed:
exit code \$res from '\$command' is < 0 or >= 128" >&2
			exit $res
		fi

		# Find current state depending on run success or failure.
		# A special exit code of 125 means cannot test.
		if [ $res -eq 125 ]
		then
			state='skip'
		elif [ $res -gt 0 ]
		then
			state="$TERM_BAD"
		else
			state="$TERM_GOOD"
		fi

		git bisect--helper --bisect-state $state >"$GIT_DIR/BISECT_RUN"
		res=$?

		cat "$GIT_DIR/BISECT_RUN"

		if sane_grep "first $TERM_BAD commit could be any of" "$GIT_DIR/BISECT_RUN" \
			>/dev/null
		then
			gettextln "bisect run cannot continue any more" >&2
			exit $res
		fi

		if [ $res -ne 0 ]
		then
			eval_gettextln "bisect run failed:
'bisect-state \$state' exited with error code \$res" >&2
			exit $res
		fi

		if sane_grep "is the first $TERM_BAD commit" "$GIT_DIR/BISECT_RUN" >/dev/null
		then
			gettextln "bisect run success"
			exit 0;
		fi

	done
}

get_terms () { # Get config options.
	if test -s "$GIT_DIR/BISECT_TERMS"
	then
		{
		read TERM_BAD
		read TERM_GOOD
		} <"$GIT_DIR/BISECT_TERMS" # Manual parsing. Does this handle bad input well?
	fi
}

case "$#" in # actual main routine
0)
	usage ;; # if no arguments were provided
*)
	cmd="$1"
	get_terms
	shift
	case "$cmd" in
	help)
		git bisect -h ;;
	start)
		git bisect--helper --bisect-start "$@" ;;
	bad|good|new|old|"$TERM_BAD"|"$TERM_GOOD")
		git bisect--helper --bisect-state "$cmd" "$@" ;;
    # continues parsing and calling the right command
	*)
		usage ;; # No match. Give usage
	esac
esac
```

We can identify a need for:
1. Getting and setting of configuration values.
2. Getting and setting values into the local value directory
2. Parsing user input
3. Returning help messages

### How it should look like
```lush
let [GOOD, BAD] = cfg get git.general.{GOOD BAD} | assert type($val) == Option::Some
# Use binary search to find the commit that introduced a bug
fn git bisect { # Okay
    # If this is called no matching subroutine has been called.
    # Lets print help then
    help git bisect
}

struct GCHash{
    val: String
    fn ctor(val: String) { 
        assert $val ~= "[a-fA-F0-9]+" 
        $self.val = $val
    }
}

impl exists for GCHash {
    fn exists -> bool {
        ret git show $self.val | exists
    }
}

<!-- git bisect start [--term-{new,bad}=<term> --term-{old,good}=<term>] -->
<!--             [--no-checkout] [--first-parent] [<bad> [<good>...]] [--] [<paths>...] -->
# Start git bisect
fn git bisect start(
        # rest arg can match 0 elemnts by default. Therefore it is always optional
        start_and_bads...: GCHash # First hash is bad commit, rest are known good commits
        <delim>
        paths...: FilePath # Files known to lead to the bug
        # Flags are optional by default
        --term-new: String # The term to use for new 
        --term-bad: String # The term to use for bad
        --term-old: String # The term to use for old
        --term-good: String # The term to use for good
        ) {
    assert {$start_and_bads | map {$it | exists} | all {$it == $true}} 
        -m "known good and bad commits must be existing git commits"
    data get git.bisect | insert start $start | save
    data insert git.bisect paths $paths

    [[name value];
      [NEW $term-new]
      [BAD $term-bad]
      [OLD $term-old]
      [GOOD $term-good]
    ] | filter {$val.2 | exists} | data insert git.bisect
}

# Use <cmd>... to automatically bisect.
fn git bisect run (cmd: File, args...: Any) -> String { 
# cmd must be a file (checked by the shell). Args can be a variable amount of arguments of any type
    # let mut [lower, upper] = data get git.bisect.{lower, upper} | assert type($val) == Option::Some
    let mut [lower, upper] = data expect git.bisect.{lower, upper}
    while $lower < $upper {
        #... binary search logic
        match { cmd $args } {
          $EXIT_SUCC => {$upper = lower-upper}
          $EXIT_FAIL => {$lower = upper-lower}
          _ => exit "cmd return status out of range"
        }
    }
}
```
