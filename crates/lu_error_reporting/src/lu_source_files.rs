
        // DO NOT EDIT THIS FILE. IT IS AUTOGENERATED
        pub(crate) const FILE_TO_STR: &[(&'static str, &'static str)] = &[
        ("src/main.rs",r#####"use std::env;

use clap::App;
use lu_cli::start_cli;
use lu_error::lu_source_code_item;
use lu_interpreter::{Interpreter, InterpreterCfg};
use lu_interpreter_structs::*;
use lu_stdx::new_amtx;
use lu_text_util::SourceCode;

fn main() {
    std::process::exit(ret_code_main())
}

fn ret_code_main() -> i32 {
    let _ = env_logger::builder()
        .format_timestamp(None)
        .is_test(false)
        .try_init()
        .unwrap();

    // Create a home for the homeless :)
    if let Err(e) = lu_cfg_home::init_home_dir() {
        println!("{:?}", e);
        println!("Aborting because of error");
        return 1;
    }

    let arg_matches = App::new("lush")
        .version("0.1")
        .author("Leonhard Kipp. <leonhard.kipp@alumni.fh-aachen.de>")
        .about("Lu-Shell Interpreter")
        .args_from_usage(
            "--debug      'Runs in debug mode'
            [FILE]      'File to run. If no file is provided a REPL is started'",
        )
        .get_matches();

    let mut global_frame = make_global_frame();

    if arg_matches.is_present("debug") {
        // It is a debug session
        set_new_dbg_session(&mut global_frame);
    }

    if let Some(file_to_run) = arg_matches.value_of("FILE") {
        let code = match SourceCode::new_file(file_to_run.into()) {
            Ok(code) => code,
            Err(e) => {
                // TODO make LuErr display
                eprintln!("Could not read FILE argument. {:?}", e);
                return 1;
            }
        };

        let intprt_config = match InterpreterCfg::try_default() {
            Ok(cfg) => cfg,
            Err(e) => {
                // TODO better formating of e. But its so unusual
                println!("Error while generating default interpreter: {:?}", e);
                return 1;
            }
        };

        let (scope, errs) = Interpreter::ty_check(code, global_frame, &intprt_config).split();
        if !errs.is_empty() {
            if let Err(e) = lu_error_reporting::report_to_term(&errs, &scope) {
                eprintln!("Ups: An error happend, while printing errors: {}", e)
            }
            return 1;
        }
        let mut scope = new_amtx(scope);
        match Interpreter::eval(&mut scope) {
            Ok(_) => {
                // TODO v should be deserialized and passed to the parent lu-shell (if any)
                // maybe pass via flag?
            }
            Err(err) => {
                if let Err(e) = lu_error_reporting::report_to_term(&[err], &scope.lock()) {
                    eprintln!("Ups: An error happend, while printing errors: {}", e)
                }
                return 2;
            }
        };
        0
    } else {
        start_cli(global_frame);
        0
    }
}

fn make_global_frame() -> ScopeFrame<Variable> {
    let mut frame = ScopeFrame::new(ScopeFrameTag::GlobalFrame);
    //insert env vars
    for (key, value) in env::vars() {
        frame.insert_var(Variable::new(
            key,
            value.into(),
            lu_source_code_item!().into(),
        ));
    }
    frame
}
"#####)
,("crates/lu_interpreter/src/evaluate/piped_cmds_stmt.rs",r#####"use crate::evaluate::eval_prelude::*;
use lu_error::lu_source_code_item;
use lu_syntax::ast::PipedCmdsStmtNode;

impl Evaluable for PipedCmdsStmtNode {
    fn do_evaluate(&self, _: &[EvalArg], scope: &mut SyScope) -> EvalResult {
        let (mut prev_val, mut prev_val_decl) = (Value::Nil, lu_source_code_item!()); // The first cmd does not have input
        for cmd in self.piped_args() {
            prev_val = cmd.evaluate_with_args(
                &[EvalArg::CmdInVal {
                    val: prev_val,
                    decl: prev_val_decl,
                }],
                scope,
            )?;
            prev_val_decl = cmd.to_item().into();
        }

        Ok(prev_val)
    }
}
"#####)
,("crates/lu_cmds/src/external_cmds_attr.rs",r#####"use std::collections::HashMap;

use lu_error::lu_source_code_item;
use lu_interpreter_structs::{CmdAttribute, CmdAttributeVariant::*};
use once_cell::sync::Lazy;

pub(crate) static EXT_CMDS_DEF_ATTRIBUTES: Lazy<Vec<CmdAttribute>> =
    Lazy::new(|| vec![(PurityUnknown, lu_source_code_item!()).into()]);

pub(crate) static EXT_CMDS_ATTRIBUTES: Lazy<HashMap<&str, Vec<CmdAttribute>>> = Lazy::new(|| {
    let mut m = HashMap::new();
    m.insert("awk", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("bc", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("cat", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("col", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("comm", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("cut", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("date", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("diff", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("echo", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("fmt", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("grep", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("groff", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("gzip", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("gunzip", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("head", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("iconv", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("jobs", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("nl", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("pandoc", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("paste", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("pr", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("ps", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("readelf", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("sed", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("seq", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("sha256sum", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("shuf", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("sort", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("tac", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("tail", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("tee", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("tr", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("uniq", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("wc", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("xargs", vec![(Pure, lu_source_code_item!()).into()]);
    m
});
"#####)
,("crates/lu_cmds/src/lu_std/fs.rs",r#####"mod ls;

use crate::{
    cmd_prelude::*,
    lu_std::fs::ls::{FsLsCmd, LS_ENTRY_STRCT},
};

use super::LuRustStdMod;

static FS_MOD_PATH: Lazy<ModPath> = Lazy::new(|| ModPath::StdPath("std:fs".into()));

pub(crate) struct StdFsMod {}

impl LuRustStdMod for StdFsMod {
    fn id(&self) -> String {
        FS_MOD_PATH.as_std_path().unwrap().clone()
    }
    fn rust_decl(&self) -> SourceCodeItem {
        lu_source_code_item!()
    }
    fn rust_src(&self) -> SourceCode {
        lu_source_code!()
    }

    fn uses(&self) -> Vec<ModPath> {
        vec![]
    }
    fn cmds(&self) -> Vec<Rc<dyn Command>> {
        vec_rc![FsLsCmd::new()]
    }

    fn strcts(&self) -> Vec<std::sync::Arc<parking_lot::RwLock<Strct>>> {
        vec![LS_ENTRY_STRCT.clone()]
    }
}
"#####)
,("crates/lu_cmds/src/lu_std/array/push.rs",r#####"use std::{ops::Deref, rc::Rc};

use crate::cmd_prelude::*;
use lu_interpreter_structs::{ModPath, SyScope};
use once_cell::sync::Lazy;

#[derive(Debug, Clone)]
pub struct ArrayPushCmd {
    sign: Signature,
}

const ARRAY_ARG_NAME: &str = "array";
const VALUES_ARG_NAME: &str = "to_push";
static PUSH_CMD_ATTRS: Lazy<Vec<CmdAttribute>> =
    Lazy::new(|| vec![CmdAttribute::new(Pure, lu_source_code_item!())]);

impl ArrayPushCmd {
    pub fn new() -> Self {
        let push_decl = lu_source_code_item!();
        let mut sign_builder = SignatureBuilder::default();
        let array_arg_ty = ArgSignature::new(
            ARRAY_ARG_NAME.into(),
            ValueType::new_array(ValueType::Generic("T".to_string()), push_decl.clone()),
            push_decl.clone().into(),
        );
        sign_builder
            .decl(push_decl.clone())
            .args(vec![array_arg_ty.clone()])
            .var_arg(ArgSignature::new(
                VALUES_ARG_NAME.to_string(),
                ValueType::Generic("T".to_string()),
                push_decl.clone().into(),
            ))
            .in_arg(ArgSignature::void(push_decl.clone().into()))
            .ret_arg(array_arg_ty);

        ArrayPushCmd {
            sign: sign_builder.build().unwrap(),
        }
    }
}

impl Command for ArrayPushCmd {
    fn name(&self) -> &str {
        "push"
    }

    fn signature(&self) -> &Signature {
        &self.sign
    }

    fn signature_item(&self) -> SourceCodeItem {
        lu_source_code_item!()
    }

    fn parent_module(&self) -> Option<&ModPath> {
        Some(&super::ARRAY_MOD_PATH)
    }

    fn attributes(&self) -> &[CmdAttribute] {
        &*PUSH_CMD_ATTRS
    }

    fn do_run_cmd(&self, scope: &mut SyScope) -> LuResult<Value> {
        let mut l_scope = scope.lock();
        let values_to_push = self
            .expect_arg(&l_scope, VALUES_ARG_NAME)
            .as_array()
            .unwrap()
            .deref()
            .clone();

        if let Value::Array(array) = self.expect_mut_arg(&mut l_scope, ARRAY_ARG_NAME) {
            let array_mut = Rc::make_mut(array);
            array_mut.extend(values_to_push);
            Ok(Value::Array(array.clone()))
        } else {
            unreachable!("ARRAY_ARG_NAME is of array type");
        }
    }
}
"#####)
,("crates/lu_cmds/src/lu_std/array.rs",r#####"mod push;

use crate::cmd_prelude::*;
use push::ArrayPushCmd;

use vec_rc::vec_rc;

use super::LuRustStdMod;

static ARRAY_MOD_PATH: Lazy<ModPath> = Lazy::new(|| ModPath::StdPath("std:array".into()));

pub(crate) struct StdArrayMod {}

impl LuRustStdMod for StdArrayMod {
    fn id(&self) -> String {
        ARRAY_MOD_PATH.as_std_path().unwrap().clone()
    }
    fn rust_decl(&self) -> SourceCodeItem {
        lu_source_code_item!()
    }
    fn rust_src(&self) -> SourceCode {
        lu_source_code!()
    }

    fn uses(&self) -> Vec<ModPath> {
        vec![]
    }
    fn cmds(&self) -> Vec<Rc<dyn Command>> {
        vec_rc![ArrayPushCmd::new()]
    }

    fn strcts(&self) -> Vec<std::sync::Arc<parking_lot::RwLock<Strct>>> {
        vec![]
    }
}
"#####)
,("crates/lu_cmds/src/lu_std/fs/ls.rs",r#####"use std::sync::Arc;

use crate::cmd_prelude::*;
use lu_error::EvalErr;
use once_cell::sync::Lazy;
use parking_lot::RwLock;

#[derive(Debug, Clone)]
pub struct FsLsCmd {
    sign: Signature,
}

const PATHS_ARG_NAME: &str = "paths";
static LS_CMD_ATTRS: Lazy<Vec<CmdAttribute>> =
    Lazy::new(|| vec![CmdAttribute::new(Pure, lu_source_code_item!())]);

const LS_ENTRY_STRCT_NAME: &str = "LsEntry";
const LS_ENTRY_FIELD_0: &str = "Name";
const LS_ENTRY_FIELD_1: &str = "Type";
const LS_ENTRY_FIELD_2: &str = "Size";

pub(crate) static LS_ENTRY_STRCT: Lazy<Arc<RwLock<Strct>>> = Lazy::new(|| {
    let decl = lu_source_code_item!();
    let ls_entry_strct = Strct::new(
        LS_ENTRY_STRCT_NAME.into(),
        vec![
            StrctField::new(LS_ENTRY_FIELD_0.into(), ValueType::String, 0, decl.clone()),
            StrctField::new(LS_ENTRY_FIELD_1.into(), ValueType::String, 1, decl.clone()),
            StrctField::new(LS_ENTRY_FIELD_2.into(), ValueType::String, 1, decl.clone()),
        ],
        decl,
    );
    Arc::new(RwLock::new(ls_entry_strct))
});

impl FsLsCmd {
    pub fn new() -> Self {
        let ls_decl = lu_source_code_item!();
        let mut sign_builder = SignatureBuilder::default();
        sign_builder
            .decl(ls_decl.clone())
            .var_arg(ArgSignature::new(
                PATHS_ARG_NAME.to_string(),
                ValueType::String,
                ls_decl.clone().into(),
            ))
            .ret_arg(ArgSignature::new(
                "LsTable".into(),
                ValueType::Strct(Arc::downgrade(&*LS_ENTRY_STRCT)),
                ls_decl.clone().into(),
            ));

        FsLsCmd {
            sign: sign_builder.build().unwrap(),
        }
    }
}

impl Command for FsLsCmd {
    fn name(&self) -> &str {
        "ls"
    }

    fn signature(&self) -> &Signature {
        &self.sign
    }

    fn signature_item(&self) -> SourceCodeItem {
        lu_source_code_item!()
    }

    fn parent_module(&self) -> Option<&ModPath> {
        Some(&super::FS_MOD_PATH)
    }

    fn attributes(&self) -> &[CmdAttribute] {
        &*LS_CMD_ATTRS
    }

    fn do_run_cmd(&self, scope: &mut SyScope) -> LuResult<Value> {
        let mut entries = vec![];

        let pwd = scope
            .lock()
            .find_var("PWD")
            .map(|var| var.val.as_string())
            .flatten()
            .expect("pwd always string")
            .clone();
        assert!(!pwd.ends_with("/"));

        let pattern = "*"; // TODO take pattern as arg

        let glob_pattern = format!("{}/{}", pwd, pattern);
        debug!("ls {}", glob_pattern);
        let paths = glob::glob(&glob_pattern).map_err(|e| EvalErr::Message(e.to_string()))?;

        for path in paths {
            let path = path.map_err(|e| EvalErr::Message(e.to_string()))?;
            let path_name = path
                .display()
                .to_string()
                .strip_prefix(&format!("{}/", pwd))
                .expect("Pattern includes pwd")
                .to_string();
            let md = path
                .metadata()
                .map_err(|e| EvalErr::Message(e.to_string()))?;

            let path_type = if md.file_type().is_dir() {
                "Directory"
            } else if md.file_type().is_file() {
                "File"
            } else {
                "Symlink"
            }
            .to_string();

            entries.push(Value::new_strct(
                LS_ENTRY_STRCT_NAME.into(),
                vec![
                    (LS_ENTRY_FIELD_0.into(), path_name.into()),
                    (LS_ENTRY_FIELD_1.into(), path_type.into()),
                    (LS_ENTRY_FIELD_2.into(), md.len().into()),
                ],
            ))
        }

        Ok(Value::new_array(entries))
    }
}
"#####)
,("crates/lu_cmds/src/print.rs",r#####"use lu_interpreter_structs::ModPath;

use crate::cmd_prelude::*;

#[derive(Debug, Clone)]
pub struct PrintCmd {
    sign: Signature,
}

const TO_PRINT_ARG_NAME: &str = "to_print";
static PRINT_CMD_ATTRS: Lazy<Vec<CmdAttribute>> =
    Lazy::new(|| vec![CmdAttribute::new(Pure, lu_source_code_item!())]);

impl PrintCmd {
    pub fn new() -> Self {
        let print_decl = lu_source_code_item!();
        let mut sign_builder = SignatureBuilder::default();
        sign_builder
            .decl(print_decl.clone())
            .var_arg(ArgSignature::new(
                TO_PRINT_ARG_NAME.to_string(),
                ValueType::Any,
                print_decl.clone().into(),
            ))
            .in_arg(ArgSignature::void(print_decl.clone().into()))
            .ret_arg(ArgSignature::ret(ValueType::Nil, print_decl.into()));
        PrintCmd {
            sign: sign_builder.build().unwrap(),
        }
    }
}

impl Command for PrintCmd {
    fn name(&self) -> &str {
        "print"
    }

    fn signature(&self) -> &Signature {
        &self.sign
    }

    fn signature_item(&self) -> SourceCodeItem {
        lu_source_code_item!()
    }

    fn parent_module(&self) -> Option<&ModPath> {
        None
    }

    fn do_run_cmd(&self, scope: &mut SyScope) -> LuResult<Value> {
        let mut l_scope = scope.lock();
        let args = self.take_var_arg(&mut l_scope, TO_PRINT_ARG_NAME).clone();

        if let Some(redir_to) = l_scope.find_var_mut(REDIR0) {
            let new_val = match std::mem::replace(&mut redir_to.val, Value::Nil) {
                Value::Array(arr) => {
                    let mut inner_arr = (*arr).clone();
                    inner_arr.extend(args);
                    Value::new_array(inner_arr)
                }
                Value::String(_) => todo!(),
                Value::Command(_) => todo!(),
                _ => unreachable!(),
            };
            redir_to.val = new_val;
        } else {
            // Simple print
            for arg in args {
                print!("{}", arg.to_string())
            }
            println!("");
        }
        Ok(Value::Nil)
    }

    fn attributes(&self) -> &[CmdAttribute] {
        &*PRINT_CMD_ATTRS
    }
}

const REDIR0: &str = "REDIR0";
"#####)
,("crates/lu_cmds/src/run_external_cmd.rs",r#####"use crate::external_cmds_attr::EXT_CMDS_ATTRIBUTES;
use crate::{cmd_prelude::*, external_cmds_attr::EXT_CMDS_DEF_ATTRIBUTES};
use std::{io::Write, process::Stdio};

use lu_error::{lu_source_code_item, EvalErr, LuResult, SourceCodeItem};
use lu_interpreter_structs::external_cmd;
use lu_syntax::{ast::CmdStmtNode, AstNode};
use once_cell::unsync::OnceCell;

#[derive(Debug, Clone, new)]
pub struct RunExternalCmd {
    /// The node in the AST which is evaluated by this Command
    pub cmd_node: CmdStmtNode,
    pub cmd_name: String,
    // TODO this could be global..., but would need adaptation of the signature() method from
    // Command
    #[new(default)]
    signature: OnceCell<Signature>,
}

impl Command for RunExternalCmd {
    fn name(&self) -> &str {
        &self.cmd_name
    }

    fn signature(&self) -> &Signature {
        self.signature
            .get_or_init(|| external_cmd::external_cmd_signature())
    }

    fn signature_item(&self) -> SourceCodeItem {
        lu_source_code_item!() // TODO fixup line number
    }

    fn parent_module(&self) -> Option<&lu_interpreter_structs::ModPath> {
        None
    }

    fn attributes(&self) -> &[CmdAttribute] {
        EXT_CMDS_ATTRIBUTES
            .get(self.name())
            .map(|attrs| attrs.as_ref())
            .unwrap_or(&EXT_CMDS_DEF_ATTRIBUTES)
    }

    fn do_run_cmd(&self, scope: &mut SyScope) -> LuResult<Value> {
        let l_scope = scope.lock();

        let args = self.expect_args(&l_scope);
        let args: Vec<String> = args.iter().map(Value::to_string).collect();
        let stdin = self.get_in(&l_scope).cloned().unwrap_or(Value::Nil);

        let mut child = std::process::Command::new(self.cmd_name.clone())
            .args(args)
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .spawn()
            .map_err(|e| {
                EvalErr::SpawningExternalProcessFailed(self.cmd_node.to_item(), e.to_string())
            })?;

        if !stdin.is_nil() {
            child
                .stdin
                .as_mut()
                .expect("Cmd stdin always correctly captured :)")
                .write_all(stdin.to_string().as_bytes())
                .map_err(|e| {
                    EvalErr::ExternalCmdStdinWriteErr(self.cmd_node.to_item(), format!("{:?}", e))
                })?;
        }

        let output = child.wait_with_output().map_err(|e| {
            EvalErr::ExternalCmdStdoutReadErr(self.cmd_node.to_item(), format!("{:?}", e))
        })?;

        if output.status.success() {
            let raw_output = String::from_utf8(output.stdout)?;
            Ok(Value::BareWord(raw_output))
        } else {
            Err(EvalErr::ExternalCmdFailed(self.cmd_node.to_item()).into())
        }
    }
}
"#####)
,("crates/lu_interpreter_structs/src/special_scope_vars.rs",r#####"use log::debug;
use lu_error::lu_source_code_item;
use lu_stdx::{new_amtx, AMtx};

use crate::dbg_state::DbgState;
use crate::Value;
use crate::{Scope, ScopeFrame, Variable};

const DBG_SESSION_VAR_NAME: &str = "DBG_SESSION";
pub fn get_dbg_session(scope: &Scope<Variable>) -> Option<&AMtx<DbgState>> {
    scope
        .find_var(DBG_SESSION_VAR_NAME)
        .map(|var| match &var.val {
            Value::DbgState(s) => Some(s),
            _ => None,
        })
        .flatten()
}

pub fn set_new_dbg_session(frame: &mut ScopeFrame<Variable>) {
    debug!("Inserting new DBG_SESSION");
    frame.insert_var(Variable::new(
        DBG_SESSION_VAR_NAME.to_string(),
        Value::DbgState(new_amtx(DbgState::default())),
        lu_source_code_item!().into(),
    ));
}

const SILENCE_VAR_NAME: &str = "SILENCE_STMT_RETURNS";
pub fn set_silence_stmt_returns(silence: bool, frame: &mut ScopeFrame<Variable>) {
    frame.insert_var(Variable::new(
        SILENCE_VAR_NAME.to_string(),
        Value::Bool(silence),
        lu_source_code_item!().into(),
    ));
}

pub fn get_silence_stmt_returns(scope: &Scope<Variable>) -> Option<bool> {
    scope
        .find_var(SILENCE_VAR_NAME)
        .map(|var| var.val.as_bool())
        .flatten()
        .cloned()
}
"#####)
,("crates/lu_interpreter_structs/src/user_def_tys/function.rs",r#####"use crate::{
    CmdAttribute, CmdAttributeVariant, Command, FlagVariant, ModPath, SyScope, Value, ValueType,
    VarDeclNode, Variable,
};
use derive_builder::Builder;
use derive_new::new;
use log::trace;
use lu_error::{lu_source_code_item, LuResult, SourceCodeItem};
use lu_syntax::ast::{ArgSignatureNode, FnStmtNode, SignatureNode};
use lu_syntax::{AstNode, AstToken};
use lu_syntax_elements::constants::{IN_ARG_NAME, RET_ARG_NAME, VAR_ARGS_DEF_NAME};
use serde::{Deserialize, Serialize};

pub type ArgDecl = SourceCodeItem;

#[derive(Clone, Debug, Hash, new, Serialize, Deserialize, PartialEq, Eq)]
pub struct ArgSignature {
    pub name: String,
    pub ty: ValueType,
    #[new(default)] // TODO this default should be false, making every flag necessary
    pub is_opt: bool, // TODO this is prob a bad idea???
    pub decl: ArgDecl,
}

impl ArgSignature {
    pub fn void(decl: ArgDecl) -> ArgSignature {
        ArgSignature::new("unused".into(), ValueType::Nil, decl)
    }

    /// ArgSignature with default in name
    pub fn in_(ty: ValueType, decl: ArgDecl) -> ArgSignature {
        ArgSignature::new(IN_ARG_NAME.into(), ty, decl)
    }

    /// ArgSignature with default ret name
    pub fn ret(ty: ValueType, decl: ArgDecl) -> ArgSignature {
        ArgSignature::new(RET_ARG_NAME.into(), ty, decl)
    }

    pub fn from_node(
        n: Option<ArgSignatureNode>,
        fallback_name: &str,
        fallback_decl: ArgDecl,
    ) -> Self {
        let name = n.as_ref().map(|n| n.name()).unwrap_or(fallback_name.into());
        let fallback_ty = ValueType::Unspecified;
        let decl: ArgDecl = n
            .as_ref()
            .map(|n| n.to_item())
            .unwrap_or_else(|| fallback_decl.into());
        let ty = n
            .as_ref()
            .map(|in_node| {
                in_node.type_().map(|ty| {
                    // Ty should always be some
                    ValueType::from_node(&ty.into_type())
                })
            })
            .flatten()
            .unwrap_or(fallback_ty); // or if in is not specified, use fallback

        ArgSignature::new(name, ty, decl)
    }

    pub fn to_var(&self) -> Variable {
        Variable::new(self.name.clone(), Value::Nil, self.decl.clone().into())
    }
}

#[derive(Clone, Debug, new, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct FlagSignature {
    pub long_name: Option<String>,
    pub short_name: Option<char>,
    pub ty: ValueType,
    #[new(value = "true")]
    pub is_opt: bool,
    pub decl: SourceCodeItem,
}

impl FlagSignature {
    pub fn is_named_by(&self, name: &str) -> bool {
        let mut result = false;
        if let Some(long_name) = &self.long_name {
            result = result || name == long_name
        }
        if let Some(short_name) = &self.short_name {
            result = result || name.len() == 1 && &name.chars().next().unwrap() == short_name
        }
        result
    }

    pub fn best_name(&self) -> String {
        self.long_name
            .clone()
            .or(self.short_name.map(|c| c.to_string()))
            .unwrap()
    }
    pub fn is_required(&self) -> bool {
        !self.is_opt
    }
    pub fn to_var(&self) -> Variable {
        let name = self
            .long_name
            .clone()
            .or(self.short_name.map(|c| c.to_string()))
            .expect("Either long or shortname set");
        Variable::new(name, Value::Nil, VarDeclNode::CatchAll(self.decl.clone()))
    }
}

#[derive(Clone, Debug, new, Builder, Serialize, Deserialize, Hash, PartialEq, Eq)]
pub struct Signature {
    #[builder(default)]
    pub args: Vec<ArgSignature>,
    #[builder(setter(strip_option), default)]
    pub var_arg: Option<ArgSignature>,
    #[builder(default)]
    pub flags: Vec<FlagSignature>,
    #[builder(default = "Signature::default_in_ret_void_arg()")]
    pub in_arg: ArgSignature,
    #[builder(default = "Signature::default_in_ret_void_arg()")]
    pub ret_arg: ArgSignature,

    pub decl: SourceCodeItem,
}

impl Signature {
    fn default_in_ret_void_arg() -> ArgSignature {
        ArgSignature::new("Unused".to_string(), ValueType::Nil, lu_source_code_item!())
    }
    pub fn req_flags(&self) -> Vec<FlagVariant> {
        self.flags
            .iter()
            .filter(|flag_sign| flag_sign.is_required())
            .map(|flag_sign| {
                if let Some(long_flag_name) = &flag_sign.long_name {
                    FlagVariant::LongFlag(long_flag_name.clone())
                } else if let Some(short_flag_name) = flag_sign.short_name {
                    FlagVariant::ShortFlag(short_flag_name)
                } else {
                    unreachable!()
                }
            })
            .collect()
    }

    pub fn default_signature(fn_sign_node_decl: SourceCodeItem) -> Signature {
        Signature::new(
            Vec::new(),
            Some(ArgSignature::new(
                VAR_ARGS_DEF_NAME.into(),
                ValueType::Any,
                fn_sign_node_decl.clone().into(),
            )),
            Vec::new(),
            ArgSignature::new(
                IN_ARG_NAME.into(),
                ValueType::Unspecified,
                fn_sign_node_decl.clone().into(),
            ),
            ArgSignature::new(
                RET_ARG_NAME.into(),
                ValueType::Unspecified,
                fn_sign_node_decl.clone().into(),
            ),
            fn_sign_node_decl,
        )
    }

    pub fn from_sign_and_stmt(
        sign_node: Option<SignatureNode>,
        fn_signature_decl: SourceCodeItem,
    ) -> Signature {
        if let Some(sign_node) = sign_node {
            Signature::source_signature(sign_node, fn_signature_decl)
        } else {
            Signature::default_signature(fn_signature_decl)
        }
    }

    pub fn source_signature(
        sign_node: SignatureNode,
        fallback_arg_decl: SourceCodeItem,
    ) -> Signature {
        let in_ty =
            ArgSignature::from_node(sign_node.in_arg(), IN_ARG_NAME, fallback_arg_decl.clone());
        let ret_ty = ArgSignature::from_node(sign_node.ret_arg(), RET_ARG_NAME, fallback_arg_decl);

        let args: Vec<ArgSignature> = sign_node
            .args()
            .iter()
            .map(|arg_node| -> ArgSignature {
                let arg_name = arg_node.name();
                let ty = arg_node
                    .type_()
                    .map(|ty_node| ValueType::from_node(&ty_node.into_type()))
                    .unwrap_or(ValueType::Unspecified);
                ArgSignature::new(arg_name, ty, arg_node.to_item())
            })
            .collect();
        let flags = sign_node
            .flags()
            .map(|flag_node| -> FlagSignature {
                let long_name = flag_node.long_name();
                let short_name = flag_node.short_name();
                let ty = flag_node
                    .type_()
                    .map(|ty_node| ValueType::from_node(&ty_node.into_type()))
                    .unwrap_or(ValueType::Bool); // Flags have a default ty of bool.
                FlagSignature::new(long_name, short_name, ty, flag_node.to_item())
            })
            .collect();
        let var_arg = sign_node.var_arg().map(|var_arg_node| {
            let name = var_arg_node.name();
            let ty = var_arg_node
                .type_()
                .map(|ty_node| ValueType::from_node(&ty_node.into_type()))
                .unwrap_or(ValueType::Any);
            ArgSignature::new(name, ty, var_arg_node.to_item())
        });
        let sign = Signature::new(args, var_arg, flags, in_ty, ret_ty, sign_node.to_item());
        trace!("Generated Signature: {:#?}", sign);
        sign
    }
}

/// Function is a struct containing all needed information for a function/closure
/// This should allow for less lookup in the ast later on (and easier handling of funcs)
#[derive(Educe)]
#[educe(Debug)]
#[derive(Clone)]
pub struct Function {
    pub name: String,
    /// A signature is always present (if not user provided, defaulted.)
    pub signature: Signature,
    pub fn_node: FnStmtNode,
    // For closures only
    pub captured_vars: Vec<Variable>,

    pub attributes: Vec<CmdAttribute>,

    /// Set when function is inserted into scope
    pub parent_module: ModPath,
}

impl Function {
    pub fn new(
        name: String,
        signature: Signature,
        attributes: Vec<CmdAttribute>,
        fn_node: FnStmtNode,
        source_file_id: ModPath,
    ) -> Self {
        Self {
            name,
            signature,
            fn_node,
            captured_vars: Vec::new(),
            parent_module: source_file_id,
            attributes,
        }
    }

    pub fn from_node(fn_stmt: &FnStmtNode, source_file_id: ModPath) -> Function {
        let name = fn_stmt.name().unwrap_or("".to_string());
        // Source the signature (either user provided or default)
        let sign = Signature::from_sign_and_stmt(fn_stmt.signature(), fn_stmt.decl_item());
        let attrs = Self::attrs_from_node(fn_stmt);

        Function::new(name, sign, attrs, fn_stmt.clone(), source_file_id)
    }

    fn attrs_from_node(fn_stmt: &FnStmtNode) -> Vec<CmdAttribute> {
        let mut attrs = vec![];
        if let Some(impure_token) = fn_stmt.impure_attr() {
            attrs.push(CmdAttribute::new(
                CmdAttributeVariant::Impure,
                impure_token.to_item(),
            ));
        } else {
            // By default all lu-functions are pure :)
            // This is okay, as there will be a warning for all impure function calls
            attrs.push(CmdAttribute::new(
                CmdAttributeVariant::Pure,
                lu_source_code_item!(),
            ));
        }
        attrs
    }
}

impl Command for Function {
    fn name(&self) -> &str {
        &self.name
    }

    fn do_run_cmd(&self, _: &mut SyScope) -> LuResult<Value> {
        unreachable!(
            r#"
            Can't have evaluate/fn_stmt here, as that would require knowledge of eval here.
            This would lead to a circular dependency 
            (lu_interpreter_structs -> evaluate)
            (evaluate -> lu_interpreter_structs)
            Therefore we hack around the interface and provide the Command::as_function interface
            so that evaluate/cmd_stmt can react to this particular situation.
            This is isn't optimal, but the best solution
            "#
        );
    }

    fn as_function(&self) -> Option<&Function> {
        Some(self)
    }

    fn as_function_mut(&mut self) -> Option<&mut Function> {
        Some(self)
    }

    fn signature(&self) -> &Signature {
        &self.signature
    }

    fn signature_item(&self) -> SourceCodeItem {
        self.fn_node.decl_item()
    }

    fn parent_module(&self) -> Option<&ModPath> {
        Some(&self.parent_module)
    }

    fn attributes(&self) -> &[crate::CmdAttribute] {
        &self.attributes
    }
}
"#####)
,("crates/lu_interpreter_structs/src/external_cmd.rs",r#####"use lu_error::lu_source_code_item;
use lu_syntax_elements::constants::{IN_ARG_NAME, RET_ARG_NAME, VAR_ARGS_DEF_NAME};

use crate::{ArgSignature, Signature, ValueType};

pub fn external_cmd_signature() -> Signature {
    let lu_item = lu_source_code_item!();
    Signature::new(
        Vec::new(),
        Some(ArgSignature::new(
            VAR_ARGS_DEF_NAME.into(),
            ValueType::Any,
            lu_item.clone(),
        )),
        Vec::new(),
        ArgSignature::new(IN_ARG_NAME.into(), ValueType::Any, lu_item.clone()),
        ArgSignature::new(RET_ARG_NAME.into(), ValueType::Any, lu_item.clone()),
        lu_item,
    )
}
"#####)
,("crates/lu_test_support/src/lib.rs",r#####"#[macro_use]
extern crate manifest_dir_macros;
pub mod binary;
mod playground;
pub mod test_prelude;

#[macro_use]
extern crate vec_rc;

use std::rc::Rc;

use lu_error::lu_source_code_item;
pub use playground::*;
use pretty_env_logger::env_logger;

use lu_cmds::PrintCmd;
use lu_interpreter::InterpreterCfg;
use lu_interpreter_structs::{Command, ScopeFrame, ScopeFrameTag, Value, VarDeclNode, Variable};
pub use temp_file::TempFile as TmpFile;

pub fn init_logger() {
    let _ = env_logger::builder()
        .format_timestamp(None)
        .is_test(true)
        .try_init();
}

pub fn make_test_interpreter() -> (ScopeFrame<Variable>, InterpreterCfg) {
    make_test_interpreter_in_playground(Playground::new())
}

pub fn make_test_interpreter_in_playground(
    playground: Playground,
) -> (ScopeFrame<Variable>, InterpreterCfg) {
    (
        make_test_global_frame(playground.root().to_string_lossy().to_string()),
        InterpreterCfg {
            plugin_dir: playground.plugin_dir(),
        },
    )
}

fn make_test_global_frame(pwd: String) -> ScopeFrame<Variable> {
    let cmds: Vec<Rc<dyn Command>> = vec_rc![PrintCmd::new()];

    let mut frame = ScopeFrame::new(ScopeFrameTag::GlobalFrame);
    for cmd in cmds {
        frame.insert_var(Variable::new(
            cmd.name().to_string(),
            Value::new_func(cmd),
            VarDeclNode::Dummy,
        ));
    }
    frame.insert_var(Variable::new(
        "PWD".into(),
        pwd.clone().into(),
        lu_source_code_item!().into(),
    ));
    std::env::set_var("PWD", pwd);
    frame
}

pub fn make_tmp_file(text: &[u8]) -> TmpFile {
    temp_file::with_contents(text)
}
"#####)
        ];
    