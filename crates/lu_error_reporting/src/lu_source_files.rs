
        // DO NOT EDIT THIS FILE. IT IS AUTOGENERATED
        pub(crate) const FILE_TO_STR: &[(&'static str, &'static str)] = &[
        ("src/main.rs",r#####"use std::env;

use clap::App;
use lu_cli::start_cli;
use lu_cmds::builtin;
use lu_error::lu_source_code_item;
use lu_interpreter::{Interpreter, InterpreterCfg};
use lu_interpreter_structs::*;
use lu_stdx::new_amtx;
use lu_text_util::SourceCode;

fn main() {
    std::process::exit(ret_code_main())
}

fn ret_code_main() -> i32 {
    let _ = env_logger::builder()
        .format_timestamp(None)
        .is_test(false)
        .try_init()
        .unwrap();

    // Create a home for the homeless :)
    if let Err(e) = lu_cfg_home::init_home_dir() {
        println!("{:?}", e);
        println!("Aborting because of error");
        return 1;
    }

    let arg_matches = App::new("lush")
        .version("0.1")
        .author("Leonhard Kipp. <leonhard.kipp@alumni.fh-aachen.de>")
        .about("Lu-Shell Interpreter")
        .args_from_usage(
            "--debug      'Runs in debug mode'
            [FILE]      'File to run. If no file is provided a REPL is started'",
        )
        .get_matches();

    let mut global_frame = make_global_frame();

    if arg_matches.is_present("debug") {
        // It is a debug session
        set_new_dbg_session(&mut global_frame);
    }

    if let Some(file_to_run) = arg_matches.value_of("FILE") {
        let code = match SourceCode::new_file(file_to_run.into()) {
            Ok(code) => code,
            Err(e) => {
                // TODO make LuErr display
                eprintln!("Could not read FILE argument. {:?}", e);
                return 1;
            }
        };

        let intprt_config = match InterpreterCfg::try_default() {
            Ok(cfg) => cfg,
            Err(e) => {
                // TODO better formating of e. But its so unusual
                println!("Error while generating default interpreter: {:?}", e);
                return 1;
            }
        };

        let (scope, errs) = Interpreter::ty_check(code, global_frame, &intprt_config).split();
        if !errs.is_empty() {
            if let Err(e) = lu_error_reporting::report_to_term(&errs, &scope) {
                eprintln!("Ups: An error happend, while printing errors: {}", e)
            }
            return 1;
        }
        let mut scope = new_amtx(scope);
        match Interpreter::eval(&mut scope) {
            Ok(_) => {
                // TODO v should be deserialized and passed to the parent lu-shell (if any)
                // maybe pass via flag?
            }
            Err(err) => {
                if let Err(e) = lu_error_reporting::report_to_term(&[err], &scope.lock()) {
                    eprintln!("Ups: An error happend, while printing errors: {}", e)
                }
                return 2;
            }
        };
        0
    } else {
        start_cli(global_frame);
        0
    }
}

fn make_global_frame() -> ScopeFrame<Variable> {
    let mut frame = ScopeFrame::new(ScopeFrameTag::GlobalFrame);
    //insert env vars
    for (key, value) in env::vars() {
        frame.insert_var(Variable::new(
            key,
            value.into(),
            lu_source_code_item!().into(),
        ));
    }

    // insert builtin cmds
    for cmd in builtin::all_builtin_cmds() {
        frame.insert_var(Variable::new_func(cmd));
    }
    frame
}
"#####)
,("crates/lu_error/src/lib.rs",r#####"use serde::{Deserialize, Serialize};
use std::{convert::TryInto, error::Error, ops::Range};
use text_size::TextRange;

mod ast_err;
mod eval_err;
mod fs_err;
mod parse_err;
mod ty_err;
pub mod util;

#[macro_use]
extern crate derive_new;
extern crate derive_more;
// #[macro_use]
// extern crate educe;
extern crate strum_macros;

pub use ast_err::*;
pub use eval_err::EvalErr;
pub use fs_err::FsErr;
pub use parse_err::{ParseErr, ParseErrs};
pub use ty_err::*;

use std::result;

pub type LuResult<T> = result::Result<T, LuErr>;
pub type LuResults<T> = result::Result<T, Vec<LuErr>>;

#[derive(Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
pub enum LuErr {
    Parse(ParseErr),
    Ty(TyErr),
    FS(FsErr),
    Eval(EvalErr),
    Ast(AstErr),
    Internal(String),
}

impl<E: Error> From<E> for LuErr {
    fn from(e: E) -> Self {
        LuErr::Internal(e.to_string())
    }
}

impl From<ParseErr> for LuErr {
    fn from(e: ParseErr) -> Self {
        LuErr::Parse(e)
    }
}

impl From<EvalErr> for LuErr {
    fn from(e: EvalErr) -> Self {
        LuErr::Eval(e)
    }
}

impl From<TyErr> for LuErr {
    fn from(e: TyErr) -> Self {
        LuErr::Ty(e)
    }
}
impl From<AstErr> for LuErr {
    fn from(e: AstErr) -> Self {
        LuErr::Ast(e)
    }
}
// impl From<FsErr> for LuErr {
//     fn from(e: FsErr) -> Self {
//         LuErr::FS(e)
//     }
// }

/// An item in the source code to be used in the `Error` enum.
#[derive(Clone, PartialEq, Eq, Serialize, Deserialize, Hash, Debug)]
// #[educe(Debug)]
// use derive_more::Display;
// #[display(fmt = "{}/{:?}..{:?}", content, range.start() as 32, range.end() as 32)]
pub struct SourceCodeItem {
    pub content: String,
    pub range: TextRange,
    // #[educe(Debug(ignore))]
    #[serde(skip)]
    pub sf_node_addr: usize,
}

impl SourceCodeItem {
    // TODO adapt ctor and users
    pub fn new(
        range: Range<usize>,
        content: impl Into<String>,
        sf_node_addr: impl Into<usize>,
    ) -> SourceCodeItem {
        let content = content.into();
        SourceCodeItem {
            range: TextRange::new(
                range.start.try_into().unwrap(),
                range.end.try_into().unwrap(),
            ),
            content,
            sf_node_addr: sf_node_addr.into(),
        }
    }

    pub fn is_lu_source_code_item(&self) -> bool {
        self.sf_node_addr == usize::MAX
    }

    pub fn lu_line(&self) -> usize {
        self.range.start().into()
    }

    pub fn lu_source_code_file_name(&self) -> &str {
        assert!(self.is_lu_source_code_item());
        &self.content
    }

    pub fn tmp_todo_item() -> SourceCodeItem {
        SourceCodeItem::new(999..999, "TMP_ITEM", 1337 as usize)
    }
}

/// New SourceCodeItem pointing to the file and line from the caller
#[macro_export]
macro_rules! lu_source_code_item {
    () => {
        lu_source_code_item!(0)
    };
    ($line_count_below:expr) => {{
        {
            let f_name = file!();
            log::debug!("File macro: {}", f_name);
            let line = line!();
            let line = (line as i32 + $line_count_below) as u32;
            // TODO better source code item
            lu_error::SourceCodeItem::new(
                (line as usize)..(line as usize),
                f_name.clone(),
                usize::MAX,
            )
        }
    }};
}
"#####)
,("crates/lu_interpreter/src/evaluate/piped_cmds_stmt.rs",r#####"use crate::evaluate::eval_prelude::*;
use lu_error::lu_source_code_item;
use lu_syntax::ast::PipedCmdsStmtNode;

impl Evaluable for PipedCmdsStmtNode {
    fn do_evaluate(&self, _: &[EvalArg], scope: &mut SyScope) -> EvalResult {
        let (mut prev_val, mut prev_val_decl) = (Value::Nil, lu_source_code_item!()); // The first cmd does not have input
        for cmd in self.piped_args() {
            prev_val = cmd.evaluate_with_args(
                &[EvalArg::CmdInVal {
                    val: prev_val,
                    decl: prev_val_decl,
                }],
                scope,
            )?;
            prev_val_decl = cmd.to_item().into();
        }

        Ok(prev_val)
    }
}
"#####)
,("crates/lu_cmds/src/external_cmds_attr.rs",r#####"use std::collections::HashMap;

use lu_error::lu_source_code_item;
use lu_interpreter_structs::{CmdAttribute, CmdAttributeVariant::*};
use once_cell::sync::Lazy;

pub(crate) static EXT_CMDS_DEF_ATTRIBUTES: Lazy<Vec<CmdAttribute>> =
    Lazy::new(|| vec![(PurityUnknown, lu_source_code_item!()).into()]);

pub(crate) static EXT_CMDS_ATTRIBUTES: Lazy<HashMap<&str, Vec<CmdAttribute>>> = Lazy::new(|| {
    let mut m = HashMap::new();
    m.insert("awk", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("bc", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("cat", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("col", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("comm", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("cut", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("date", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("diff", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("echo", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("fmt", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("grep", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("groff", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("gzip", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("gunzip", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("head", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("iconv", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("jobs", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("nl", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("pandoc", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("paste", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("pr", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("ps", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("readelf", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("sed", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("seq", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("sha256sum", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("shuf", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("sort", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("tac", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("tail", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("tee", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("tr", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("uniq", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("wc", vec![(Pure, lu_source_code_item!()).into()]);
    m.insert("xargs", vec![(Pure, lu_source_code_item!()).into()]);
    m
});
"#####)
,("crates/lu_cmds/src/lu_std/fs.rs",r#####"mod ls;

use crate::{
    cmd_prelude::*,
    lu_std::fs::ls::{FsLsCmd, LS_ENTRY_STRCT},
};

use super::LuRustStdMod;

static FS_MOD_PATH: Lazy<ModPath> = Lazy::new(|| ModPath::StdPath("std:fs".into()));

pub(crate) struct StdFsMod {}

impl LuRustStdMod for StdFsMod {
    fn id(&self) -> String {
        FS_MOD_PATH.as_std_path().unwrap().clone()
    }
    fn rust_decl(&self) -> SourceCodeItem {
        lu_source_code_item!()
    }

    fn uses(&self) -> Vec<ModPath> {
        vec![]
    }
    fn cmds(&self) -> Vec<Rc<dyn Command>> {
        vec_rc![FsLsCmd::new()]
    }

    fn strcts(&self) -> Vec<std::sync::Arc<parking_lot::RwLock<Strct>>> {
        vec![LS_ENTRY_STRCT.clone()]
    }
}
"#####)
,("crates/lu_cmds/src/lu_std/array/push.rs",r#####"use std::{ops::Deref, rc::Rc};

use crate::cmd_prelude::*;
use lu_interpreter_structs::{ModPath, SyScope};
use once_cell::sync::Lazy;

#[derive(Debug, Clone)]
pub struct ArrayPushCmd {
    sign: Signature,
}

const ARRAY_ARG_NAME: &str = "array";
const VALUES_ARG_NAME: &str = "to_push";
static PUSH_CMD_ATTRS: Lazy<Vec<CmdAttribute>> =
    Lazy::new(|| vec![CmdAttribute::new(Pure, lu_source_code_item!())]);

impl ArrayPushCmd {
    pub fn new() -> Self {
        let mut sign_builder = SignatureBuilder::default();
        let array_arg_ty = ArgSignature::new(
            ARRAY_ARG_NAME.into(),
            ValueType::new_array(ValueType::Generic("T".to_string()), lu_source_code_item!()),
            lu_source_code_item!(-1),
        );
        sign_builder
            .decl(lu_source_code_item!())
            .args(vec![array_arg_ty.clone()])
            .var_arg(ArgSignature::new(
                VALUES_ARG_NAME.to_string(),
                ValueType::Generic("T".to_string()),
                lu_source_code_item!(-1),
            ))
            .in_arg(ArgSignature::void(lu_source_code_item!()))
            .ret_arg(array_arg_ty);

        ArrayPushCmd {
            sign: sign_builder.build().unwrap(),
        }
    }
}

impl Command for ArrayPushCmd {
    fn name(&self) -> &str {
        "push"
    }

    fn signature(&self) -> &Signature {
        &self.sign
    }

    fn signature_item(&self) -> SourceCodeItem {
        lu_source_code_item!()
    }

    fn parent_module(&self) -> Option<&ModPath> {
        Some(&super::ARRAY_MOD_PATH)
    }

    fn attributes(&self) -> &[CmdAttribute] {
        &*PUSH_CMD_ATTRS
    }

    fn do_run_cmd(&self, scope: &mut SyScope) -> LuResult<Value> {
        let mut l_scope = scope.lock();
        let values_to_push = self
            .expect_arg(&l_scope, VALUES_ARG_NAME)
            .as_array()
            .unwrap()
            .deref()
            .clone();

        if let Value::Array(array) = self.expect_mut_arg(&mut l_scope, ARRAY_ARG_NAME) {
            let array_mut = Rc::make_mut(array);
            array_mut.extend(values_to_push);
            Ok(Value::Array(array.clone()))
        } else {
            unreachable!("ARRAY_ARG_NAME is of array type");
        }
    }
}
"#####)
,("crates/lu_cmds/src/lu_std/array.rs",r#####"mod push;

use crate::cmd_prelude::*;
use push::ArrayPushCmd;

use vec_rc::vec_rc;

use super::LuRustStdMod;

static ARRAY_MOD_PATH: Lazy<ModPath> = Lazy::new(|| ModPath::StdPath("std:array".into()));

pub(crate) struct StdArrayMod {}

impl LuRustStdMod for StdArrayMod {
    fn id(&self) -> String {
        ARRAY_MOD_PATH.as_std_path().unwrap().clone()
    }
    fn rust_decl(&self) -> SourceCodeItem {
        lu_source_code_item!()
    }

    fn uses(&self) -> Vec<ModPath> {
        vec![]
    }
    fn cmds(&self) -> Vec<Rc<dyn Command>> {
        vec_rc![ArrayPushCmd::new()]
    }

    fn strcts(&self) -> Vec<std::sync::Arc<parking_lot::RwLock<Strct>>> {
        vec![]
    }
}
"#####)
,("crates/lu_cmds/src/lu_std/fs/ls.rs",r#####"use std::sync::Arc;

use crate::cmd_prelude::*;
use glob::Paths;
use lu_error::EvalErr;
use once_cell::sync::Lazy;
use parking_lot::RwLock;

#[derive(Debug, Clone)]
pub struct FsLsCmd {
    sign: Signature,
}

const PATHS_VAR_ARG_NAME: &str = "paths";
static LS_CMD_ATTRS: Lazy<Vec<CmdAttribute>> =
    Lazy::new(|| vec![CmdAttribute::new(Pure, lu_source_code_item!())]);

const LS_ENTRY_STRCT_NAME: &str = "LsEntry";
const LS_ENTRY_FIELD_0: &str = "Name";
const LS_ENTRY_FIELD_1: &str = "Type";
const LS_ENTRY_FIELD_2: &str = "Size";

pub(crate) static LS_ENTRY_STRCT: Lazy<Arc<RwLock<Strct>>> = Lazy::new(|| {
    let decl = lu_source_code_item!();
    let ls_entry_strct = Strct::new(
        LS_ENTRY_STRCT_NAME.into(),
        vec![
            StrctField::new(LS_ENTRY_FIELD_0.into(), ValueType::String, 0, decl.clone()),
            StrctField::new(LS_ENTRY_FIELD_1.into(), ValueType::String, 1, decl.clone()),
            StrctField::new(LS_ENTRY_FIELD_2.into(), ValueType::String, 1, decl.clone()),
        ],
        decl,
    );
    Arc::new(RwLock::new(ls_entry_strct))
});

impl FsLsCmd {
    pub fn new() -> Self {
        let ls_decl = lu_source_code_item!();
        let mut sign_builder = SignatureBuilder::default();
        sign_builder
            .decl(ls_decl.clone())
            .var_arg(ArgSignature::new(
                PATHS_VAR_ARG_NAME.to_string(),
                ValueType::FileName,
                ls_decl.clone().into(),
            ))
            .ret_arg(ArgSignature::new(
                "LsTable".into(),
                ValueType::Strct(Arc::downgrade(&*LS_ENTRY_STRCT)),
                ls_decl.clone().into(),
            ));

        FsLsCmd {
            sign: sign_builder.build().unwrap(),
        }
    }
}

impl Command for FsLsCmd {
    fn name(&self) -> &str {
        "ls"
    }

    fn signature(&self) -> &Signature {
        &self.sign
    }

    fn signature_item(&self) -> SourceCodeItem {
        lu_source_code_item!()
    }

    fn parent_module(&self) -> Option<&ModPath> {
        Some(&super::FS_MOD_PATH)
    }

    fn attributes(&self) -> &[CmdAttribute] {
        &*LS_CMD_ATTRS
    }

    fn do_run_cmd(&self, scope: &mut SyScope) -> LuResult<Value> {
        let mut entries = vec![];

        let pwd = scope
            .lock()
            .find_var("PWD")
            .map(|var| var.val.as_string())
            .flatten()
            .expect("pwd always string")
            .clone();
        assert!(!pwd.ends_with("/"));

        let mut l_scope = scope.lock();
        let patterns = {
            let mut patterns: Vec<_> = self
                .expect_args(PATHS_VAR_ARG_NAME, &mut l_scope)
                .iter()
                .map(|pattern| match pattern {
                    Value::FileName(pattern) => pattern.clone(),
                    _ => unreachable!(),
                })
                .collect();
            if patterns.is_empty() {
                patterns.push("*".into())
            }
            patterns
        };

        let matching_paths: Result<Vec<Paths>, EvalErr> = patterns
            .into_iter()
            .map(|pattern| {
                let glob_pattern = format!("{}/{}", pwd, pattern);
                glob::glob(&glob_pattern).map_err(|e| EvalErr::Message(e.to_string()))
            })
            .collect();

        for path in matching_paths?.into_iter().flatten() {
            let path = path.map_err(|e| EvalErr::Message(e.to_string()))?;
            let path_name = path
                .display()
                .to_string()
                .strip_prefix(&format!("{}/", pwd))
                .expect("Pattern includes pwd")
                .to_string();
            let md = path
                .metadata()
                .map_err(|e| EvalErr::Message(e.to_string()))?;

            let path_type = if md.file_type().is_dir() {
                "Directory"
            } else if md.file_type().is_file() {
                "File"
            } else {
                "Symlink"
            }
            .to_string();

            entries.push(Value::new_strct(
                LS_ENTRY_STRCT_NAME.into(),
                vec![
                    (LS_ENTRY_FIELD_0.into(), path_name.into()),
                    (LS_ENTRY_FIELD_1.into(), path_type.into()),
                    (LS_ENTRY_FIELD_2.into(), md.len().into()),
                ],
            ))
        }

        Ok(Value::new_array(entries))
    }
}
"#####)
,("crates/lu_cmds/src/print.rs",r#####"use lu_interpreter_structs::ModPath;

use crate::cmd_prelude::*;

#[derive(Debug, Clone)]
pub struct PrintCmd {
    sign: Signature,
}

const TO_PRINT_ARG_NAME: &str = "to_print";
static PRINT_CMD_ATTRS: Lazy<Vec<CmdAttribute>> =
    Lazy::new(|| vec![CmdAttribute::new(Pure, lu_source_code_item!())]);

impl PrintCmd {
    pub fn new() -> Self {
        let print_decl = lu_source_code_item!();
        let mut sign_builder = SignatureBuilder::default();
        sign_builder
            .decl(print_decl.clone())
            .var_arg(ArgSignature::new(
                TO_PRINT_ARG_NAME.to_string(),
                ValueType::Any,
                print_decl.clone().into(),
            ))
            .in_arg(ArgSignature::void(print_decl.clone().into()))
            .ret_arg(ArgSignature::ret(ValueType::Nil, print_decl.into()));
        PrintCmd {
            sign: sign_builder.build().unwrap(),
        }
    }
}

impl Command for PrintCmd {
    fn name(&self) -> &str {
        "print"
    }

    fn signature(&self) -> &Signature {
        &self.sign
    }

    fn signature_item(&self) -> SourceCodeItem {
        lu_source_code_item!()
    }

    fn parent_module(&self) -> Option<&ModPath> {
        None
    }

    fn do_run_cmd(&self, scope: &mut SyScope) -> LuResult<Value> {
        let mut l_scope = scope.lock();
        let args = self.take_var_arg(&mut l_scope, TO_PRINT_ARG_NAME).clone();

        if let Some(redir_to) = l_scope.find_var_mut(REDIR0) {
            let new_val = match std::mem::replace(&mut redir_to.val, Value::Nil) {
                Value::Array(arr) => {
                    let mut inner_arr = (*arr).clone();
                    inner_arr.extend(args);
                    Value::new_array(inner_arr)
                }
                Value::String(_) => todo!(),
                Value::Command(_) => todo!(),
                _ => unreachable!(),
            };
            redir_to.val = new_val;
        } else {
            // Simple print
            for arg in args {
                print!("{}", arg.to_string())
            }
            println!("");
        }
        Ok(Value::Nil)
    }

    fn attributes(&self) -> &[CmdAttribute] {
        &*PRINT_CMD_ATTRS
    }
}

const REDIR0: &str = "REDIR0";
"#####)
,("crates/lu_cmds/src/builtin/is_set.rs",r#####"use crate::cmd_prelude::*;

#[derive(Debug, Clone)]
pub struct IsSetBuiltin {
    sign: Signature,
}

const VAR_NAME_TO_LOOKUP: &str = "var_name";
static IS_SET_BUILTIN_ATTRS: Lazy<Vec<CmdAttribute>> =
    Lazy::new(|| vec![CmdAttribute::new(Pure, lu_source_code_item!())]);

impl IsSetBuiltin {
    pub fn new() -> Self {
        let mut sign_builder = SignatureBuilder::default();
        sign_builder
            .decl(lu_source_code_item!())
            .args(vec![ArgSignature::new(
                VAR_NAME_TO_LOOKUP.to_string(),
                ValueType::String,
                lu_source_code_item!(-3).into(),
            )])
            .ret_arg(ArgSignature::new(
                "value_exists".into(),
                ValueType::Bool,
                lu_source_code_item!(),
            ));
        IsSetBuiltin {
            sign: sign_builder.build().unwrap(),
        }
    }
}

impl Command for IsSetBuiltin {
    fn name(&self) -> &str {
        "is_set"
    }

    fn signature(&self) -> &Signature {
        &self.sign
    }

    fn signature_item(&self) -> SourceCodeItem {
        lu_source_code_item!()
    }

    fn parent_module(&self) -> Option<&ModPath> {
        None
    }

    fn do_run_cmd(&self, scope: &mut SyScope) -> LuResult<Value> {
        let l_scope = scope.lock();
        let var_to_find = self
            .expect_arg(&l_scope, VAR_NAME_TO_LOOKUP)
            .coerce_to_string()
            .unwrap();

        let var_to_find_exists = l_scope.find_var(var_to_find).is_some();

        Ok(Value::Bool(var_to_find_exists))
    }

    fn attributes(&self) -> &[CmdAttribute] {
        &*IS_SET_BUILTIN_ATTRS
    }
}
"#####)
,("crates/lu_cmds/src/builtin/ty_of.rs",r#####"use crate::cmd_prelude::*;

#[derive(Debug, Clone)]
pub struct TyOfBuiltin {
    sign: Signature,
}

const TO_GET_TY_OF_ARG: &str = "value";
static TY_OF_BUILTIN_ATTRS: Lazy<Vec<CmdAttribute>> =
    Lazy::new(|| vec![CmdAttribute::new(Pure, lu_source_code_item!())]);

impl TyOfBuiltin {
    pub fn new() -> Self {
        let mut sign_builder = SignatureBuilder::default();
        sign_builder
            .decl(lu_source_code_item!())
            .args(vec![ArgSignature::new(
                TO_GET_TY_OF_ARG.to_string(),
                ValueType::Any,
                lu_source_code_item!(-3).into(),
            )])
            .ret_arg(ArgSignature::new(
                "value_type".into(),
                ValueType::String,
                lu_source_code_item!(),
            ));
        TyOfBuiltin {
            sign: sign_builder.build().unwrap(),
        }
    }
}

impl Command for TyOfBuiltin {
    fn name(&self) -> &str {
        "type_of"
    }

    fn signature(&self) -> &Signature {
        &self.sign
    }

    fn signature_item(&self) -> SourceCodeItem {
        lu_source_code_item!()
    }

    fn parent_module(&self) -> Option<&ModPath> {
        None
    }

    fn do_run_cmd(&self, scope: &mut SyScope) -> LuResult<Value> {
        let mut l_scope = scope.lock();
        let val = self.expect_arg(&mut l_scope, TO_GET_TY_OF_ARG).clone();
        Ok(Value::String(val.get_ty().to_string()))
    }

    fn attributes(&self) -> &[CmdAttribute] {
        &*TY_OF_BUILTIN_ATTRS
    }
}
"#####)
,("crates/lu_cmds/src/run_external_cmd.rs",r#####"use crate::external_cmds_attr::EXT_CMDS_ATTRIBUTES;
use crate::{cmd_prelude::*, external_cmds_attr::EXT_CMDS_DEF_ATTRIBUTES};
use std::{io::Write, process::Stdio};

use lu_error::{lu_source_code_item, EvalErr, LuResult, SourceCodeItem};
use lu_interpreter_structs::external_cmd;
use lu_syntax::{ast::CmdStmtNode, AstNode};
use once_cell::unsync::OnceCell;

#[derive(Debug, Clone, new)]
pub struct RunExternalCmd {
    /// The node in the AST which is evaluated by this Command
    pub cmd_node: CmdStmtNode,
    pub cmd_name: String,
    // TODO this could be global..., but would need adaptation of the signature() method from
    // Command
    #[new(default)]
    signature: OnceCell<Signature>,
}

impl Command for RunExternalCmd {
    fn name(&self) -> &str {
        &self.cmd_name
    }

    fn signature(&self) -> &Signature {
        self.signature
            .get_or_init(|| external_cmd::external_cmd_signature())
    }

    fn signature_item(&self) -> SourceCodeItem {
        lu_source_code_item!() // TODO fixup line number
    }

    fn parent_module(&self) -> Option<&lu_interpreter_structs::ModPath> {
        None
    }

    fn attributes(&self) -> &[CmdAttribute] {
        EXT_CMDS_ATTRIBUTES
            .get(self.name())
            .map(|attrs| attrs.as_ref())
            .unwrap_or(&EXT_CMDS_DEF_ATTRIBUTES)
    }

    fn do_run_cmd(&self, scope: &mut SyScope) -> LuResult<Value> {
        let l_scope = scope.lock();

        let args = self.expect_args(
            &self
                .signature()
                .var_arg
                .as_ref()
                .expect("ExternalCmd has vararg")
                .name,
            &l_scope,
        );

        // Historic shells expand wildcards (*, **) to all files matching the pattern in the
        // current PWD. Lush doesn't do the same automatically for internal cmds. For better
        // compatability, we now expand filenames
        let mut args_as_str = vec![];
        for arg in &**args {
            if let Value::FileName(f_name) = arg {
                match glob::glob(&f_name) {
                    Ok(entries) => {
                        for entry in entries {
                            match entry {
                                Ok(path) => args_as_str.push(path.display().to_string()),
                                Err(e) => {
                                    return Err(EvalErr::Message(e.to_string()).into());
                                }
                            }
                        }
                    }
                    Err(e) => unreachable!("TODO check all globs are valid: {}", e),
                }
            } else {
                args_as_str.push(arg.to_string())
            }
        }

        let args = args_as_str;
        let stdin = self.get_in(&l_scope).cloned().unwrap_or(Value::Nil);

        let mut child = std::process::Command::new(self.cmd_name.clone())
            .args(args)
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .spawn()
            .map_err(|e| {
                EvalErr::SpawningExternalProcessFailed(self.cmd_node.to_item(), e.to_string())
            })?;

        if !stdin.is_nil() {
            child
                .stdin
                .as_mut()
                .expect("Cmd stdin always correctly captured :)")
                .write_all(stdin.to_string().as_bytes())
                .map_err(|e| {
                    EvalErr::ExternalCmdStdinWriteErr(self.cmd_node.to_item(), format!("{:?}", e))
                })?;
        }

        let output = child.wait_with_output().map_err(|e| {
            EvalErr::ExternalCmdStdoutReadErr(self.cmd_node.to_item(), format!("{:?}", e))
        })?;

        if output.status.success() {
            let raw_output = String::from_utf8(output.stdout)?;
            Ok(Value::BareWord(raw_output))
        } else {
            Err(EvalErr::ExternalCmdFailed(self.cmd_node.to_item()).into())
        }
    }
}
"#####)
,("crates/lu_interpreter_structs/src/special_scope_vars.rs",r#####"use log::debug;
use lu_error::lu_source_code_item;
use lu_stdx::{new_amtx, AMtx};

use crate::dbg_state::DbgState;
use crate::Value;
use crate::{Scope, ScopeFrame, Variable};

const DBG_SESSION_VAR_NAME: &str = "DBG_SESSION";
pub fn get_dbg_session(scope: &Scope<Variable>) -> Option<&AMtx<DbgState>> {
    scope
        .find_var(DBG_SESSION_VAR_NAME)
        .map(|var| match &var.val {
            Value::DbgState(s) => Some(s),
            _ => None,
        })
        .flatten()
}

pub fn set_new_dbg_session(frame: &mut ScopeFrame<Variable>) {
    debug!("Inserting new DBG_SESSION");
    frame.insert_var(Variable::new(
        DBG_SESSION_VAR_NAME.to_string(),
        Value::DbgState(new_amtx(DbgState::default())),
        lu_source_code_item!().into(),
    ));
}

const SILENCE_VAR_NAME: &str = "SILENCE_STMT_RETURNS";
pub fn set_silence_stmt_returns(silence: bool, frame: &mut ScopeFrame<Variable>) {
    frame.insert_var(Variable::new(
        SILENCE_VAR_NAME.to_string(),
        Value::Bool(silence),
        lu_source_code_item!().into(),
    ));
}

pub fn get_silence_stmt_returns(scope: &Scope<Variable>) -> Option<bool> {
    scope
        .find_var(SILENCE_VAR_NAME)
        .map(|var| var.val.as_bool())
        .flatten()
        .cloned()
}
"#####)
,("crates/lu_interpreter_structs/src/user_def_tys/function.rs",r#####"use crate::{
    CmdAttribute, CmdAttributeVariant, Command, FlagVariant, ModPath, SyScope, Value, ValueType,
    VarDeclNode, Variable,
};
use derive_builder::Builder;
use derive_new::new;
use log::trace;
use lu_error::{lu_source_code_item, LuResult, SourceCodeItem};
use lu_syntax::ast::{ArgSignatureNode, FnStmtNode, SignatureNode};
use lu_syntax::{AstNode, AstToken};
use lu_syntax_elements::constants::{IN_ARG_NAME, RET_ARG_NAME, VAR_ARGS_DEF_NAME};
use serde::{Deserialize, Serialize};

pub type ArgDecl = SourceCodeItem;

#[derive(Clone, Debug, Hash, new, Serialize, Deserialize, PartialEq, Eq)]
pub struct ArgSignature {
    pub name: String,
    pub ty: ValueType,
    #[new(default)] // TODO this default should be false, making every flag necessary
    pub is_opt: bool, // TODO this is prob a bad idea???
    pub decl: ArgDecl,
}

impl ArgSignature {
    pub fn void(decl: ArgDecl) -> ArgSignature {
        ArgSignature::new("unused".into(), ValueType::Nil, decl)
    }

    /// ArgSignature with default in name
    pub fn in_(ty: ValueType, decl: ArgDecl) -> ArgSignature {
        ArgSignature::new(IN_ARG_NAME.into(), ty, decl)
    }

    /// ArgSignature with default ret name
    pub fn ret(ty: ValueType, decl: ArgDecl) -> ArgSignature {
        ArgSignature::new(RET_ARG_NAME.into(), ty, decl)
    }

    pub fn from_node(
        n: Option<ArgSignatureNode>,
        fallback_name: &str,
        fallback_decl: ArgDecl,
    ) -> Self {
        let name = n.as_ref().map(|n| n.name()).unwrap_or(fallback_name.into());
        let fallback_ty = ValueType::Unspecified;
        let decl: ArgDecl = n
            .as_ref()
            .map(|n| n.to_item())
            .unwrap_or_else(|| fallback_decl.into());
        let ty = n
            .as_ref()
            .map(|in_node| {
                in_node.type_().map(|ty| {
                    // Ty should always be some
                    ValueType::from_node(&ty.into_type())
                })
            })
            .flatten()
            .unwrap_or(fallback_ty); // or if in is not specified, use fallback

        ArgSignature::new(name, ty, decl)
    }

    pub fn to_var(&self) -> Variable {
        Variable::new(self.name.clone(), Value::Nil, self.decl.clone().into())
    }
}

#[derive(Clone, Debug, new, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct FlagSignature {
    pub long_name: Option<String>,
    pub short_name: Option<char>,
    pub ty: ValueType,
    pub is_opt: bool,
    pub decl: SourceCodeItem,
}

impl FlagSignature {
    pub fn is_named_by(&self, name: &str) -> bool {
        let mut result = false;
        if let Some(long_name) = &self.long_name {
            result = result || name == long_name
        }
        if let Some(short_name) = &self.short_name {
            result = result || name.len() == 1 && &name.chars().next().unwrap() == short_name
        }
        result
    }

    pub fn best_name(&self) -> String {
        self.long_name
            .clone()
            .or(self.short_name.map(|c| c.to_string()))
            .unwrap()
    }
    pub fn is_required(&self) -> bool {
        !self.is_opt
    }
    pub fn to_var(&self) -> Variable {
        let name = self
            .long_name
            .clone()
            .or(self.short_name.map(|c| c.to_string()))
            .expect("Either long or shortname set");
        Variable::new(name, Value::Nil, VarDeclNode::CatchAll(self.decl.clone()))
    }
}

#[derive(Clone, Debug, new, Builder, Serialize, Deserialize, Hash, PartialEq, Eq)]
pub struct Signature {
    #[builder(default)]
    pub args: Vec<ArgSignature>,
    #[builder(setter(strip_option), default)]
    pub var_arg: Option<ArgSignature>,
    #[builder(default)]
    pub flags: Vec<FlagSignature>,
    #[builder(default = "Signature::default_in_ret_void_arg()")]
    pub in_arg: ArgSignature,
    #[builder(default = "Signature::default_in_ret_void_arg()")]
    pub ret_arg: ArgSignature,

    pub decl: SourceCodeItem,
}

impl Signature {
    fn default_in_ret_void_arg() -> ArgSignature {
        ArgSignature::new("Unused".to_string(), ValueType::Nil, lu_source_code_item!())
    }
    pub fn req_flags(&self) -> Vec<FlagVariant> {
        self.flags
            .iter()
            .filter(|flag_sign| flag_sign.is_required())
            .map(|flag_sign| {
                if let Some(long_flag_name) = &flag_sign.long_name {
                    FlagVariant::LongFlag(long_flag_name.clone())
                } else if let Some(short_flag_name) = flag_sign.short_name {
                    FlagVariant::ShortFlag(short_flag_name)
                } else {
                    unreachable!()
                }
            })
            .collect()
    }

    pub fn default_signature(fn_sign_node_decl: SourceCodeItem) -> Signature {
        Signature::new(
            Vec::new(),
            Some(ArgSignature::new(
                VAR_ARGS_DEF_NAME.into(),
                ValueType::Any,
                fn_sign_node_decl.clone().into(),
            )),
            Vec::new(),
            ArgSignature::new(
                IN_ARG_NAME.into(),
                ValueType::Unspecified,
                fn_sign_node_decl.clone().into(),
            ),
            ArgSignature::new(
                RET_ARG_NAME.into(),
                ValueType::Unspecified,
                fn_sign_node_decl.clone().into(),
            ),
            fn_sign_node_decl,
        )
    }

    pub fn from_sign_and_stmt(
        sign_node: Option<SignatureNode>,
        fn_signature_decl: SourceCodeItem,
    ) -> Signature {
        if let Some(sign_node) = sign_node {
            Signature::source_signature(sign_node, fn_signature_decl)
        } else {
            Signature::default_signature(fn_signature_decl)
        }
    }

    pub fn source_signature(
        sign_node: SignatureNode,
        fallback_arg_decl: SourceCodeItem,
    ) -> Signature {
        let in_ty =
            ArgSignature::from_node(sign_node.in_arg(), IN_ARG_NAME, fallback_arg_decl.clone());
        let ret_ty = ArgSignature::from_node(sign_node.ret_arg(), RET_ARG_NAME, fallback_arg_decl);

        let args: Vec<ArgSignature> = sign_node
            .args()
            .iter()
            .map(|arg_node| -> ArgSignature {
                let arg_name = arg_node.name();
                let ty = arg_node
                    .type_()
                    .map(|ty_node| ValueType::from_node(&ty_node.into_type()))
                    .unwrap_or(ValueType::Unspecified);
                ArgSignature::new(arg_name, ty, arg_node.to_item())
            })
            .collect();
        let flags = sign_node
            .flags()
            .map(|flag_node| -> FlagSignature {
                let long_name = flag_node.long_name();
                let short_name = flag_node.short_name();
                let ty = flag_node
                    .type_()
                    .map(|ty_node| ValueType::from_node(&ty_node.into_type()))
                    .unwrap_or(ValueType::Bool); // Flags have a default ty of bool.
                let optional = !flag_node.is_required();
                FlagSignature::new(long_name, short_name, ty, optional, flag_node.to_item())
            })
            .collect();
        let var_arg = sign_node.var_arg().map(|var_arg_node| {
            let name = var_arg_node.name();
            let ty = var_arg_node
                .type_()
                .map(|ty_node| ValueType::from_node(&ty_node.into_type()))
                .unwrap_or(ValueType::Any);
            ArgSignature::new(name, ty, var_arg_node.to_item())
        });
        let sign = Signature::new(args, var_arg, flags, in_ty, ret_ty, sign_node.to_item());
        trace!("Generated Signature: {:#?}", sign);
        sign
    }
}

/// Function is a struct containing all needed information for a function/closure
/// This should allow for less lookup in the ast later on (and easier handling of funcs)
#[derive(Educe)]
#[educe(Debug)]
#[derive(Clone)]
pub struct Function {
    pub name: String,
    /// A signature is always present (if not user provided, defaulted.)
    pub signature: Signature,
    pub fn_node: FnStmtNode,
    // For closures only
    pub captured_vars: Vec<Variable>,

    pub attributes: Vec<CmdAttribute>,

    /// Set when function is inserted into scope
    pub parent_module: ModPath,
}

impl Function {
    pub fn new(
        name: String,
        signature: Signature,
        attributes: Vec<CmdAttribute>,
        fn_node: FnStmtNode,
        source_file_id: ModPath,
    ) -> Self {
        Self {
            name,
            signature,
            fn_node,
            captured_vars: Vec::new(),
            parent_module: source_file_id,
            attributes,
        }
    }

    pub fn from_node(fn_stmt: &FnStmtNode, source_file_id: ModPath) -> Function {
        let name = fn_stmt.name().unwrap_or("".to_string());
        // Source the signature (either user provided or default)
        let sign = Signature::from_sign_and_stmt(fn_stmt.signature(), fn_stmt.decl_item());
        let attrs = Self::attrs_from_node(fn_stmt);

        Function::new(name, sign, attrs, fn_stmt.clone(), source_file_id)
    }

    fn attrs_from_node(fn_stmt: &FnStmtNode) -> Vec<CmdAttribute> {
        let mut attrs = vec![];
        if let Some(impure_token) = fn_stmt.impure_attr() {
            attrs.push(CmdAttribute::new(
                CmdAttributeVariant::Impure,
                impure_token.to_item(),
            ));
        } else {
            // By default all lu-functions are pure :)
            // This is okay, as there will be a warning for all impure function calls
            attrs.push(CmdAttribute::new(
                CmdAttributeVariant::Pure,
                lu_source_code_item!(),
            ));
        }
        attrs
    }
}

impl Command for Function {
    fn name(&self) -> &str {
        &self.name
    }

    fn do_run_cmd(&self, _: &mut SyScope) -> LuResult<Value> {
        unreachable!(
            r#"
            Can't have evaluate/fn_stmt here, as that would require knowledge of eval here.
            This would lead to a circular dependency 
            (lu_interpreter_structs -> evaluate)
            (evaluate -> lu_interpreter_structs)
            Therefore we hack around the interface and provide the Command::as_function interface
            so that evaluate/cmd_stmt can react to this particular situation.
            This is isn't optimal, but the best solution
            "#
        );
    }

    fn as_function(&self) -> Option<&Function> {
        Some(self)
    }

    fn as_function_mut(&mut self) -> Option<&mut Function> {
        Some(self)
    }

    fn signature(&self) -> &Signature {
        &self.signature
    }

    fn signature_item(&self) -> SourceCodeItem {
        self.fn_node.decl_item()
    }

    fn parent_module(&self) -> Option<&ModPath> {
        Some(&self.parent_module)
    }

    fn attributes(&self) -> &[crate::CmdAttribute] {
        &self.attributes
    }
}
"#####)
,("crates/lu_interpreter_structs/src/external_cmd.rs",r#####"use lu_error::lu_source_code_item;
use lu_syntax_elements::constants::{IN_ARG_NAME, RET_ARG_NAME, VAR_ARGS_DEF_NAME};

use crate::{ArgSignature, Signature, ValueType};

pub fn external_cmd_signature() -> Signature {
    let lu_item = lu_source_code_item!();
    Signature::new(
        Vec::new(),
        Some(ArgSignature::new(
            VAR_ARGS_DEF_NAME.into(),
            ValueType::Any,
            lu_item.clone(),
        )),
        Vec::new(),
        ArgSignature::new(IN_ARG_NAME.into(), ValueType::Any, lu_item.clone()),
        ArgSignature::new(RET_ARG_NAME.into(), ValueType::Any, lu_item.clone()),
        lu_item,
    )
}
"#####)
,("crates/lu_interpreter_structs/src/value.rs",r#####"use enum_as_inner::EnumAsInner;
use lu_error::lu_source_code_item;
use lu_stdx::AMtx;
use lu_syntax::ast::{BareWordToken, NumberExprNode, StringExprNode};
use ordered_float::OrderedFloat;
use parking_lot::RwLock;
use std::cmp::Ordering;
use std::hash::{Hash, Hasher};
use std::sync::{Arc, Weak};
use std::{fmt::Display, rc::Rc};

use serde::{Deserialize, Serialize};

use crate::dbg_state::DbgState;
use crate::{table, Command, CommandCollection, Strct, ValueType};

#[derive(Clone, Serialize, Deserialize, EnumAsInner)]
pub enum Value {
    // Lu has value semantics. All the time! This allows for easier reasoning about
    // pure functions with inputs. However, copying large structs (Array, Table, ...)
    // may create a lot of copying. Therefore we use the COW-Idiom, by leveraging Rc::make_mut
    //
    // The following types are lu-copy
    Nil,
    Bool(bool),
    Number(OrderedFloat<f64>),
    String(String),
    BareWord(String),
    /// A file name. May contain wildcards
    FileName(String),
    // The following types are lu-copy-on-write (and therefore enclosed in a Rc)
    Array(Rc<Vec<Value>>),
    // Strcts fields
    // TODO this should contian weak pointer to decl. makes everything easier
    Strct(String, Rc<Vec<(String, Value)>>),
    #[serde(skip)]
    Command(Rc<dyn Command>),
    CommandCollection(CommandCollection),
    /// Not really lu values. But treating them as one, allows us to store them in variables
    #[serde(skip)] // TODO serialize
    StrctDecl(Arc<RwLock<Strct>>),
    #[serde(skip)] // TODO serialize
    DbgState(AMtx<DbgState>),
}

impl PartialEq for Value {
    fn eq(&self, other: &Self) -> bool {
        match (other, self) {
            (Value::Nil, Value::Nil) => true,
            (Value::Bool(lhs), Value::Bool(rhs)) => lhs == rhs,
            (Value::Number(lhs), Value::Number(rhs)) => lhs == rhs,
            (Value::String(lhs), Value::String(rhs)) => lhs == rhs,
            (Value::BareWord(lhs), Value::BareWord(rhs)) => lhs == rhs,
            (Value::Array(lhs), Value::Array(rhs)) => lhs == rhs,
            (Value::Command(lhs), Value::Command(rhs)) => Rc::ptr_eq(lhs, rhs),
            (Value::Strct(lhs_name, lhs_fields), Value::Strct(rhs_name, rhs_fields)) => {
                lhs_name == rhs_name && lhs_fields == rhs_fields
            }
            _ => false,
        }
    }
}
impl Eq for Value {}

impl PartialOrd for Value {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        match (self, other) {
            (Value::Nil, Value::Nil) => Some(Ordering::Equal),
            (Value::Bool(l), Value::Bool(r)) => l.partial_cmp(r),
            (Value::Number(l), Value::Number(r)) => l.partial_cmp(r),
            (Value::String(l), Value::String(r)) => l.partial_cmp(r),
            (Value::BareWord(l), Value::BareWord(r)) => l.partial_cmp(r),
            (Value::Array(_), Value::Array(_)) => None,
            (Value::Command(_), Value::Command(_)) => None,
            (Value::StrctDecl(_), Value::StrctDecl(_)) => None,
            _ => {
                unreachable!("Caught by ty checker");
            }
        }
    }
}

impl Hash for Value {
    fn hash<H: Hasher>(&self, state: &mut H) {
        match self {
            Value::Nil => {
                state.write_i32(1);
                state.finish();
            }
            Value::Bool(v) => v.hash(state),
            Value::Number(v) => v.hash(state),
            Value::String(v) => v.hash(state),
            Value::BareWord(v) => v.hash(state),
            Value::Array(v) => v.hash(state),
            Value::Strct(name, v) => {
                name.hash(state);
                v.hash(state);
            }
            Value::Command(func) => Rc::as_ptr(func).hash(state),
            Value::CommandCollection(col) => col.hash(state),
            Value::StrctDecl(strct) => Arc::as_ptr(strct).hash(state),
            Value::DbgState(v) => Arc::as_ptr(v).hash(state),
            Value::FileName(v) => v.hash(state),
        }
    }
}

impl Value {
    pub fn new_func(func: Rc<dyn Command>) -> Self {
        Value::Command(func)
    }
    pub fn new_strct_decl(strct: Strct) -> Self {
        Value::StrctDecl(Arc::new(RwLock::new(strct)))
    }
    pub fn new_array(vals: Vec<Value>) -> Self {
        Value::Array(Rc::new(vals))
    }
    pub fn new_strct(name: String, vals: Vec<(String, Value)>) -> Self {
        Value::Strct(name, Rc::new(vals))
    }

    pub fn expect_array(&mut self) -> &mut Vec<Value> {
        match self {
            Value::Array(vals) => Rc::make_mut(vals),
            _ => unreachable!(),
        }
    }

    pub fn is_nil(&self) -> bool {
        return self == &Value::Nil;
    }

    pub fn is_func(&self) -> bool {
        matches!(self, Value::Command(_))
    }

    /// Returns Some(true|false) if self represents a true or false value
    /// Returns None if self is not convertible to bool
    pub fn convert_to_bool(&self) -> Option<bool> {
        // TODO check what else should be false / true
        match self {
            Value::Nil => Some(false),
            Value::Bool(v) => Some(*v),
            Value::FileName(_) => None,
            Value::Number(n) => Some(*n != OrderedFloat::from(0f64)),
            Value::String(s) | Value::BareWord(s) => Some(!s.is_empty()),
            Value::Array(arr) => Some(!arr.is_empty()),
            Value::Command(_) => None,
            Value::StrctDecl(_) => None,
            Value::Strct(_, _) => None,
            Value::CommandCollection(_) => None,
            Value::DbgState(_) => None,
        }
    }

    pub fn is_of_type(&self, ty: &ValueType) -> bool {
        match (self, ty) {
            (Value::Nil, ValueType::Nil)
            | (Value::Bool(_), ValueType::Bool)
            | (Value::Number(_), ValueType::Number)
            | (Value::String(_), ValueType::String)
            | (Value::BareWord(_), ValueType::String)
            | (Value::BareWord(_), ValueType::FileName)
            | (Value::FileName(_), ValueType::String)
            | (Value::FileName(_), ValueType::FileName) => return true,
            (Value::Strct(name, _), ValueType::Strct(strct)) => {
                let strct = Weak::upgrade(strct).unwrap();
                let l_strct = strct.read();
                *name == l_strct.name
            }
            (Value::Command(_), ValueType::Func(_)) => {
                todo!("Assert signatures are the same")
            }
            (Value::Array(inner), ValueType::Array { inner_ty, .. }) => {
                // TODO add array ty to value
                if inner.is_empty() {
                    true
                } else {
                    inner[0].is_of_type(inner_ty)
                }
            }
            _ => false,
        }
    }

    pub fn get_ty(&self) -> ValueType {
        match self {
            Value::Nil => ValueType::Nil,
            Value::Bool(_) => ValueType::Bool,
            Value::Number(_) => ValueType::Number,
            Value::String(_) => ValueType::String,
            Value::BareWord(_) => ValueType::BareWord,
            Value::FileName(_) => ValueType::FileName,
            // TODO better inner_ty
            Value::Array(_) => ValueType::Array {
                inner_ty: Box::new(ValueType::Unspecified),
                inner_ty_decl: lu_source_code_item!(),
            },
            // TODO if strct contains pointer to decl return proper strct here
            Value::Strct(name, _) => ValueType::StrctName(name.clone()),
            Value::Command(cmd) => ValueType::Func(Box::new(cmd.signature().clone())),
            // TODO these should never be reachable
            Value::StrctDecl(_) => todo!("Add pseudo ValueType::StructDecl"),
            Value::DbgState(_) => todo!("Add pseudo ValueType::DbgState"),
            Value::CommandCollection(_) => todo!(),
        }
    }

    pub fn coerce_to_string(&self) -> Option<&String> {
        match self {
            Value::String(s) | Value::BareWord(s) | Value::FileName(s) => Some(s),
            _ => None,
        }
    }
}

impl std::fmt::Debug for Value {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self)
    }
}
impl Display for Value {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Value::Nil => write!(f, "Nil"),
            Value::Bool(v) => v.fmt(f),
            Value::Number(v) => v.fmt(f),
            Value::String(v) => v.fmt(f),
            Value::BareWord(v) => v.fmt(f),
            Value::Array(arr) => {
                if arr.is_empty() {
                    write!(f, "")
                } else if arr[0].as_strct().is_some() {
                    write!(f, "{}", table::to_fmt_table(arr))
                } else {
                    write!(f, "{:?}", arr)
                }
            }
            Value::Command(v) => write!(f, "Command: {} {:?}", v.name(), v.signature_item()),
            Value::StrctDecl(v) => write!(f, "{:p}", Arc::as_ptr(v)),
            Value::Strct(name, fields) => write!(f, "{}{:?}", name, fields),
            // TODO nice display here
            Value::CommandCollection(col) => write!(f, "{:?}", col),
            Value::DbgState(dbg_state) => write!(f, "{:?}", dbg_state),
            Value::FileName(s) => write!(f, "{}", s),
        }
    }
}

impl From<bool> for Value {
    fn from(v: bool) -> Self {
        Value::Bool(v)
    }
}

impl From<OrderedFloat<f64>> for Value {
    fn from(v: OrderedFloat<f64>) -> Self {
        Value::Number(v)
    }
}

impl From<u64> for Value {
    fn from(v: u64) -> Self {
        Value::Number((v as f64).into())
    }
}

impl From<String> for Value {
    fn from(s: String) -> Self {
        Value::String(s)
    }
}

impl From<&BareWordToken> for Value {
    fn from(n: &BareWordToken) -> Self {
        Value::BareWord(n.value())
    }
}

impl From<&StringExprNode> for Value {
    fn from(n: &StringExprNode) -> Self {
        Value::String(n.value())
    }
}

impl From<&NumberExprNode> for Value {
    fn from(n: &NumberExprNode) -> Self {
        Value::Number(n.value().into())
    }
}
"#####)
,("crates/lu_test_support/src/lib.rs",r#####"#[macro_use]
extern crate manifest_dir_macros;
pub mod binary;
mod playground;
pub mod test_prelude;

use lu_error::lu_source_code_item;
pub use playground::*;
use pretty_env_logger::env_logger;

use lu_cmds::builtin;
use lu_interpreter::InterpreterCfg;
use lu_interpreter_structs::{ScopeFrame, ScopeFrameTag, Variable};
pub use temp_file::TempFile as TmpFile;

pub fn init_logger() {
    let _ = env_logger::builder()
        .format_timestamp(None)
        .is_test(true)
        .try_init();
}

pub fn make_test_interpreter() -> (ScopeFrame<Variable>, InterpreterCfg) {
    make_test_interpreter_in_playground(Playground::new())
}

pub fn make_test_interpreter_in_playground(
    playground: Playground,
) -> (ScopeFrame<Variable>, InterpreterCfg) {
    (
        make_test_global_frame(playground.root().to_string_lossy().to_string()),
        InterpreterCfg {
            plugin_dir: playground.plugin_dir(),
        },
    )
}

fn make_test_global_frame(pwd: String) -> ScopeFrame<Variable> {
    let mut frame = ScopeFrame::new(ScopeFrameTag::GlobalFrame);
    // insert builtin cmds
    for cmd in builtin::all_builtin_cmds() {
        frame.insert_var(Variable::new_func(cmd));
    }
    frame.insert_var(Variable::new(
        "PWD".into(),
        pwd.clone().into(),
        lu_source_code_item!().into(),
    ));
    std::env::set_var("PWD", pwd);
    frame
}

pub fn make_tmp_file(text: &[u8]) -> TmpFile {
    temp_file::with_contents(text)
}
"#####)
        ];
    